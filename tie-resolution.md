# Tie Resolution Protocol 

**POLYAS GmbH**


Introduction
--------------------------------------------------------------------------

This document outlines the protocol used by POLYAS to resolve tie
conditions in a verifiably pseudo-random way.

A tie condition occurs when two or more candidates or choices receive an
equal number of votes in a ballot or a candidate list. In such cases, a resolution
mechanism may be required to randomly order these entities.  The primary
objective of the described protocol is to ensure that the resolution
order is in fact

- **pseudo-random**: the outcome is unpredictable and uniformly
  distributed,
- **fair**: neither the POLYAS system nor the election council can
  manipulate the outcome to favor specific candidates,
- **verifiable**: it can be audited to ensure the above conditions.

To achieve this, the process combines two sources of randomness — one
generated by the POLYAS system and one provided by the election council
— in order to determine the resolution order.  To guarantee fairness,
the POLYAS system, as described in details below, *commits* to its random
value, before the election board representative provides their randomness.

Overview of the Protocol
--------------------------------------------------------------------------

When one or more tie conditions occurs and the user representing the
election council decides to use the tie resolution process offered by
the POLYAS system, the following protocol steps are executed.

1. **The POLYAS system generates a random value `sSeed`** (the system
   seed) and computes its **commitment** by applying a hash function.
   The resulting commitment is displayed to the user, who should save it
   for later reference.

   At this point, the system also provides the user with the identifiers of
   ballots and candidate lists where the ties occur (an election can contain
   several ballots, where each ballot can consists of one or more
   candidate/choice lists).

   Note that at the point when the system generates its seed, it does
   not know the value of the user seed which is only provided in the
   next step. As the system cannot predict the user seed, it would not
   be able to bias the final tie resolution which depends on both
   seeds.

   Note also that, by displaying the commitment, the system is **bound** to
   its chosen seed. It means that it will not be later able to use a
   different value instead, because it would not be consistent with the
   displayed commitment (thanks to the _collision resistance_ of the
   used hash function).

   _**Technical Note.** To compute the commitment to a given value, we
   apply the SHA-256 function to the byte representation of this value
   (assuming the UTF-8 encoding).  SHA-256 is a state-of-the-art hashing
   method, providing both __collision resistance__ and __preimage
   resistance__, the two security properties required for the soundness
   of our method._

2. **The user is prompted to provide their random seed** `uSeed`
   (user seed).

   Note that at this point, the user still has no knowledge about the
   system's seed, even though the system is already bound to it,
   by having displayed the commitment. Therefore, the user cannot bias the
   final tie resolution outcome, by choosing a specifically crafted
   user seed.

3. **Tie resolution determined by the seeds.** The system seed (`sSeed`)
   and user seed (`uSeed`) are then combined to determine the resolution 
   order for each tie instance, using the algorithm detailed below.

4. **Audit data.** The commitment, the system seed (`sSeed`), and the 
   user seed (`uSeed`) are included in the final result documentation, 
   along with the outcome of the tie resolution process. The user should 
   now compare their saved commitment with the commitment value included in 
   the documentation.

   Including this audit data in the documentation enables independent
   verification of the correctness of the process. Specifically, the
   verifier can re-calculate the outcome using the provided seeds and
   the algorithm below and, by comparing the re-calculated outcome with
   the documented result, the verifier can confirm that the process was
   executed correctly.


Details of the Algorithm
--------------------------------------------------------------------------

Each tie condition is identified by the *ballot identifier* `bid` and
the *list identifier* `lid` where the ties occur. It also contains the
number $n$ of the candidates/choices which need to be ordered.

We will assign indices $0, \dots, (n-1)$ to these candidates/choices.
The tie resolution should produce a _resolution order_, that is a
rearrangement of the numbers from  $0$ to $(n-1)$ or, technically
speaking, a _permutation_ of $\{ 0, \dots, (n-1)\}$. For instance, if
there is a tie with four candidates, a tie resolution could output 
$1, 0, 2, 3$.

We describe now in details how this resolution order is computed for
the given tie instance defined by `sSeed`, `uSeed`, `bid`, `lid`, and
$n$.
The central building block of the resolution algorithm is function
`nextRandomNumber(upperBound)` which returns the next pseudo-random
number in range 0, ... (`upperBound` - 1). The sequence of consecutive
numbers returned by this function are determined by `sSeed`, `uSeed`,
`bid`, `lid` in the following way.

### Integers from seeds

We start by defining the sequence of pseudo-random positive integers
$d_0, d_1, \dots$ determined by `sSeed`, `uSeed`, `bid`, and `lid`.  In
this process we will use byte blocks $B_1, B_2, \dots$, defined below,
where each block $B_i$ has the length of 32 bytes and can be used to
determine (up to) four consecutive positive integers.

**Byte blocks.**
The $i$-th byte block $B_i$ is computed using the HMAC function with
the following inputs:

* HMAC key: the concatenation of `sSeed` and `uSeed`
* HMAC input: the concatenation of
  the block index $i$ (as 4 bytes), `bid`, Zero byte (0x00) and `lid`

The HMAC function used is `HmacSHA256` and the resulting block $B_i$ has
a length of 32 bytes.

**Integer sequence generation.**
We generate the integer sequence $d_0, d_1, \dots$ from the
consecutive blocks $B_0, B_1, \dots$ as follows:

- Divide each block into 4-byte pieces.
- Convert each 4-byte piece to a positive integer by applying the
  bitwise AND operator with 0x7FFFFFFF to zero-out the most
  significant bit (sign bit).
- Repeat the above steps, for consecutive blocks, until the desired
  number of integers is reached.

Using the above procedure, the first four numbers $d_0, d_1, d_2, d_3$
are determined by block $B_0$, then $d_4, d_5, d_6, d_7$ are determined by
$B_2$ and so on (until the requested number of numbers is reached).

### Next random number in the range

Now we are ready to specify how to compute
`nextRandomNumber(upperBound)` (where `upperBound` is a positive
integer). We will use for this the sequence of positive integers $d_0,
d_1, \dots$ defined above.

To compute the result of `nextRandomNumber(upperBound)`, we do the
following steps:

- Take a next integer $d$ (starting from $d_0$)

- Let $m$ be the bitmask obtained from `upperBound` $- 1$ by flipping
  all the bits, excluding the leading zeros, to 1. 

  For instance if `upperBound` $- 1$ has binary representation
  $0000\,0010\,0110$, then $m$ is $0000\,0011\,1111$. Note that $m$ is
  the smallest bitmask that leaves all integers $l$ in the range
  [0, `upperBound`) unchanged, when performing the bitwise AND operation
  between $l$ and $m$.

- Compute $a = d \ \mathtt{and} \ m$, where $\mathtt{and}$ denotes
  bitwise AND operation.

- If $a$ is smaller than `upperBound`, return $a$ as the result of
  `nextRandomNumber(upperBound)`. Otherwise, repeat the above steps,
  taking the next $d$ (if $d$ was $d_i$, then take now $d =d_{i+1}$).

The method used here, where, in the last step, the value $a$ is rejected
if it is not in the desired range (rejection sampling), guarantees that
the result is in the requested range with approximately **uniform
distribution**.

**Example.** To illustrate the above procedure, let's consider
`upperBound` = $10011$ in the binary representation (we will represent
all integers in the binary representation throughout this example). We
have therefore `upperBound` $- 1 = 10010$ and $m = 11111$.  Assume now
that we start with $d_i = 1011000$. The masked value $(d_i \
\mathtt{and} \ m)$ is then $11000$ which is bigger than `upperBound` and
therefore is rejected. We need, therefore, repeat the procedure with
$d_{i+1}$ which we assume to have value $1100111$. The masked value is
now $00111$ which is smaller than `upperBound` and therefore is accepted
as the result of the procedure.

### Random permutation

Now we use the function `nextRandomNumber` defined above to **compute the
pseudo-random resolution order**, that is a pseudo-random permutation of $\{ 0, \dots, (n-1)\}$.
We use for this a variant of Knuth shuffle
algorithm.  This process is represented by the following pseudocode.

```
function randomPermutation(n) {
    array = [0, ..., (n-1)]
    for i in 0, ..., (n-1) {
        k = nextRandomNumber(n - i) + i
        exchange array[i] and array[k]
    }
    return array
}
```

Note that the output of this function is **implicitly determined** by
values `sSeed`, `uSeed`, `bid`, and `lid` (as `nextRandomNumber` depends
on these values). We keep this dependence implicit to simplify the
notation.

